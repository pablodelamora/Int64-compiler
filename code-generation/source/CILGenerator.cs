/*
Authors:
- Gad Levy A01017986
- Jonathan Ginsburg A01021617
- Pablo de la Mora A01020365
*/

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Globalization;

namespace Int64 {

	class CILGenerator {

		private SemanticAnalyzer semanticAnalyzer;
		private FunctionSym currentFunction;
		private string currentBreakLabel;
        private string currentContinueLabel;

		int labelCounter = 0;

        //-----------------------------------------------------------

        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        } 

		public CILGenerator(SemanticAnalyzer semanticAnalyzer) {
			this.semanticAnalyzer = semanticAnalyzer;
		}
		
		// Loads variable into stack (push) by resolving if it is a local, global or parameter one
		string loadVariable(string lexeme) {
			VariableSym varSym = currentFunction.GetLocalVariableSymbolByLexeme(lexeme);
			if (varSym != null) { // Lexeme represents local variable or parameter
				if (varSym.kind == VariableSymKind.PARAMETER) {
					return "\t\tldarg '" + lexeme + "'\n";
				}
				else {
					return "\t\tldloc '" + lexeme + "'\n";
				}
			}
			else { // Lexeme represents global variable
				return "\t\tldsfld int64 Int64Program::'" + lexeme + "'\n";
			}
		}
		
		// Stores value from top of the stack (and pops) by resolving if it is a local, global or parameter one
		string storeVariable(string lexeme) {
			VariableSym varSym = currentFunction.GetLocalVariableSymbolByLexeme(lexeme);
			if (varSym != null) { // Lexeme represents local variable or parameter
				if (varSym.kind == VariableSymKind.PARAMETER) {
					return "\t\tstarg '" + lexeme + "'\n";
				}
				else {
					return "\t\tstloc '" + lexeme + "'\n";
				}
			}
			else { // Lexeme represents global variable
				return "\t\tstsfld int64 Int64Program::'" + lexeme + "'\n";
			}
		}

        //-----------------------------------------------------------
		
		public string Visit (NProgram nProgram) {
			NVarDefList nVarDefList = (NVarDefList) nProgram[0];
			NFunDefList nFunDefList = (NFunDefList) nProgram[1];
			return "// Code generated by the int64 compiler.\n\n" 
                + ".assembly 'int64' {}\n\n"
                + ".assembly extern 'int64lib' {}\n\n"
                + ".class public 'Int64Program' extends ['mscorlib']'System'.'Object' {\n" 
				+ Visit((dynamic) nVarDefList)
                + Visit((dynamic) nFunDefList)
                + "}\n";
		}

		public string Visit (NVarDefList nVarDefList) {
			string retVal = "";
			foreach (NVarDef nVarDef in nVarDefList) {
				 retVal += Visit((dynamic) nVarDef);
			}
			return retVal;
		}

		public string Visit (NVarDef nVarDef) {
			string lexeme = nVarDef.AnchorToken.Lexeme;
			if (currentFunction == null) { // Global variable
				return  "\t.field public static int64 '" + lexeme + "'\n";
			}
			else { // Local variable
				return "\t\t.locals init (int64 '" + lexeme + "')\n";
			}
		}

		public string Visit (NFunDefList nFunDefList) {
			string retVal = "";
			foreach (NFunDef nFunDef in nFunDefList) {
				retVal += Visit((dynamic) nFunDef);
			}
			return retVal;
		}

		public string Visit (NFunDef nFunDef) {
			currentFunction = semanticAnalyzer.GetFunctionSymbolByLexeme(nFunDef.AnchorToken.Lexeme);
			string lexeme = nFunDef.AnchorToken.Lexeme;
			Node parameters = nFunDef[0];
			Node varDefList = nFunDef[1];
			Node stmtList = nFunDef[2];
            string retVal = "\t.method public static hidebysig default int64 '" + lexeme + "' (" + Visit((dynamic)parameters) + ") cil managed {\n";
				if(lexeme == "main"){
					retVal += "\t\t.entrypoint\n";
				}
				retVal += Visit((dynamic) varDefList)
				+ Visit((dynamic) stmtList)
				+ "\t\tldc.i8 0\n"
				+ "\t\tret\n"
				+ "\t}\n";
			currentFunction = null;
			return retVal;
		}

		public string Visit (NParameterList nParameterList) {
			string retVal = "";
			int childrenCount = nParameterList.children.Count;
			for (int i = 0; i < childrenCount; ++i) {
				retVal += Visit((dynamic) nParameterList[i]);
				if (i != childrenCount - 1) {
					retVal += ", ";
				}
			}
			return retVal;
		}

		public string Visit (NParameter nParameter) {
			return "int64 '" + nParameter.AnchorToken.Lexeme + "'";
		}

		public string Visit (NStmtList nStmtList) {
			string retVal = "";
			foreach (Node stmt in nStmtList) {
				retVal += Visit((dynamic) stmt);
				if (stmt.GetType() == typeof(NFunCall)) {
					retVal += "\t\tpop\n";
				}
			}
			return retVal;
		}

		public string Visit (NAssign nAssign) {
			string lexeme = nAssign.AnchorToken.Lexeme;
			Node nExpr = nAssign[0];
			return Visit((dynamic) nExpr) + storeVariable(lexeme);
		}

		public string Visit (NFunCall nFunCall) {
			string lexeme = nFunCall.AnchorToken.Lexeme;
			FunctionSym functionSym = semanticAnalyzer.GetFunctionSymbolByLexeme(lexeme);
			NExprList argumentList = (NExprList) nFunCall[0];
			string argumentsPreparation = Visit(argumentList);

			string prefix = "";
			if (functionSym.kind == FunctionSymKind.STANDARD) {
				prefix = "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::";
			}
			else {
				prefix = "\t\tcall int64 class 'Int64Program'::";
			}

			string paramTypeList = "";
			for(var i = 0; i < argumentList.children.Count; i++) {
				paramTypeList += "int64";
				if(i != argumentList.children.Count - 1) {
					paramTypeList += ", ";
				}
			}
			if (lexeme == "new") lexeme = "New";
			return argumentsPreparation + prefix + "'" + lexeme + "'(" + paramTypeList + ")\n";
		}

		public string Visit (NExprList nExprList) {
			return GenericChildVisitor(nExprList);
		}

		public string Visit (NExpr nExpr) {
			string retVal = Visit((dynamic) nExpr[0]);
			if (nExpr.children.Count == 3) {
				string falseCase = GenerateLabel();
				retVal += "\t\tbrfalse " + falseCase + "\n";
				string exitTernary = GenerateLabel();
				retVal += Visit((dynamic) nExpr[1]);
				retVal += "\t\tbr " + exitTernary + "\n";
				retVal += falseCase + ":\n";
				retVal += Visit((dynamic) nExpr[2]);
				retVal += exitTernary + ":\n";
			}
			return retVal;
		}

		public string Visit (NIfStmt nIfStmt) {
			string retVal = "";
			string exitAll = GenerateLabel();
			string jumpNext = GenerateLabel();
			retVal += Visit((dynamic) nIfStmt[0]); // Visit condition
			retVal += "\t\tbrfalse " + jumpNext + "\n"; 
			retVal += Visit((dynamic) nIfStmt[1]); // Visit body
			retVal += "\t\tbr " + exitAll + "\n";
			int currentChildIndex = 2;
			bool endedInElse = false;
			while (currentChildIndex < nIfStmt.children.Count) {
				if (nIfStmt.children.Count - currentChildIndex >= 2) { // 	Assume else if
					retVal += jumpNext + ":\n";
					jumpNext = GenerateLabel();
					retVal += Visit((dynamic) nIfStmt[currentChildIndex++]); // Visit else if condition
					retVal += "\t\tbrfalse " + jumpNext + "\n";
					retVal += Visit((dynamic) nIfStmt[currentChildIndex++]); // Visit else if body
					retVal += "\t\tbr " + exitAll + "\n";
				}
				else { // Assume else
					retVal += jumpNext + ":\n"; 
					retVal += Visit((dynamic) nIfStmt[currentChildIndex++]); // Visit else body
					endedInElse = true;
				}
			}
			if (!endedInElse) {
				retVal += jumpNext + ":\n";
			}
			retVal += exitAll + ":\n";
			return retVal;
		}

		public string Visit (NSwitchStmt nSwitchStmt) {
			string retVal = "";
			string exitAll = GenerateLabel();
			Node testVar = nSwitchStmt[0];
			retVal += Visit((dynamic) testVar);
			NCaseList nCaseList = (NCaseList)nSwitchStmt[1];
			retVal += Visit((dynamic) nCaseList, exitAll);
			NStmtList nStmtList = (NStmtList)nSwitchStmt[2];
			retVal += Visit((dynamic) nStmtList);
			retVal += exitAll + ":\n";
			retVal += "\t\tpop\n";
			return retVal;
		}

		public string Visit (NCaseList nCaseList, string exitAll) {
			string retVal = "";
			foreach(NCase nCase in nCaseList) {
				string jumpNext = GenerateLabel();
				retVal += Visit(nCase, exitAll, jumpNext);
				retVal += jumpNext + ":\n";
			}
			return retVal;
		}

		public string Visit (NCase nCase, string exitAll, string jumpNext) {
			string retVal = "";
			string jumpBody = GenerateLabel();
			int childCount = nCase.children.Count;
			for (int i = 0; i < childCount; ++i) {
				Node node = nCase[i];
				if (i == childCount - 1) { // Body of case
					retVal += jumpBody + ":\n";
					retVal += "\t\tpop\n";
					retVal += Visit((dynamic) node);
					retVal += "\t\tbr " + exitAll + "\n";
				}
				else { // Case values to compare with
					retVal += "\t\tdup\n";
					if (i == childCount - 2) { // Last value to compare with
						retVal += Visit((dynamic) node);
						retVal += "\t\tceq\n";
						retVal += "\t\tbrfalse " + jumpNext + "\n";
					}
					else {
						retVal += Visit((dynamic) node);
						retVal += "\t\tceq\n";
						retVal += "\t\tbrtrue " + jumpBody + "\n";
					}
				}
			}
			return retVal;
		}

		public string Visit (NWhileStmt nWhileStmt) {
            string retVal = "";
            string continueLabel = GenerateLabel();
            string breakLabel = GenerateLabel();

			string lastContinueLabel = currentContinueLabel;
			string lastBreakLabel = currentBreakLabel;

            currentContinueLabel = continueLabel;
            currentBreakLabel = breakLabel;
        
            retVal += continueLabel + ":\n";
            retVal += Visit((dynamic) nWhileStmt[0]);
            retVal += "\t\tbrfalse " + breakLabel + "\n";
            retVal += Visit((dynamic) nWhileStmt[1]);
            retVal += "\t\tbr " + continueLabel + "\n";
            retVal += breakLabel + ":\n";

            currentContinueLabel = lastContinueLabel;
            currentBreakLabel = lastBreakLabel;

			return retVal;
		}

		public string Visit (NDoWhileStmt nDoWhileStmt) {
            string retVal = "";

            string continueLabel = GenerateLabel();
            string breakLabel = GenerateLabel();
			string jumpBody = GenerateLabel();

			string lastContinueLabel = currentContinueLabel;
			string lastBreakLabel = currentBreakLabel;
			
            currentContinueLabel = continueLabel;
            currentBreakLabel = breakLabel;
			
            retVal += jumpBody + ":\n";
            retVal += Visit((dynamic) nDoWhileStmt[0]);
            retVal += continueLabel + ":\n";
            retVal += Visit((dynamic) nDoWhileStmt[1]);
            retVal += "\t\tbrtrue " + jumpBody + "\n";
            retVal += breakLabel + ":\n";

            currentContinueLabel = lastContinueLabel;
            currentBreakLabel = lastBreakLabel;

			return retVal;
		}

		public string Visit (NForStmt nForStmt) {
			Token anchorToken = nForStmt.AnchorToken;
			string lexeme = anchorToken.Lexeme;
			string retVal = "";

            string continueLabel = GenerateLabel();
            string breakLabel = GenerateLabel();

			string lastContinueLabel = currentContinueLabel;
			string lastBreakLabel = currentBreakLabel;

			currentContinueLabel = continueLabel;
            currentBreakLabel = breakLabel;

			string sizeLocalVariable = GenerateLabel();
			VariableSym sizeLocalVarSym = new VariableSym(sizeLocalVariable, VariableSymKind.REGULAR);
			currentFunction.AddLocalVariable(sizeLocalVarSym);
			retVal += "\t\t.locals init (int64 '" + sizeLocalVariable + "')\n";

			string indexLocalVariable = GenerateLabel();
			VariableSym indexLocalVarSym = new VariableSym(indexLocalVariable, VariableSymKind.REGULAR);
			currentFunction.AddLocalVariable(indexLocalVarSym);
			retVal += "\t\t.locals init (int64 '" + indexLocalVariable + "')\n";

			string arrayHandleLocalVariable = GenerateLabel();
			VariableSym arrayHandleLocalVarSym = new VariableSym(arrayHandleLocalVariable, VariableSymKind.REGULAR);
			currentFunction.AddLocalVariable(arrayHandleLocalVarSym);
			retVal += "\t\t.locals init (int64 '" + arrayHandleLocalVariable + "')\n";

			Node nExpr = nForStmt[0];
			Node nStmtList = nForStmt[1];

			retVal += Visit((dynamic) nExpr);
			retVal += storeVariable(arrayHandleLocalVariable);
			retVal += loadVariable(arrayHandleLocalVariable);
			retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'size'(int64)\n";
			retVal += storeVariable(sizeLocalVariable);
			retVal += "\t\tldc.i8 -1\n";
			retVal += storeVariable(indexLocalVariable);
			retVal += continueLabel + ":\n";
			retVal += loadVariable(indexLocalVariable);
			retVal += "\t\tldc.i8 1\n";
			retVal += "\t\tadd\n";
			retVal += storeVariable(indexLocalVariable);
			retVal += loadVariable(indexLocalVariable);
			retVal += loadVariable(sizeLocalVariable);
			retVal += "\t\tclt\n";
			retVal += "\t\tbrfalse " + breakLabel + "\n";
			retVal += loadVariable(arrayHandleLocalVariable);
			retVal += loadVariable(indexLocalVariable);
			retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'get'(int64, int64)\n";
			retVal += storeVariable(lexeme);
			retVal += Visit((dynamic) nStmtList);
			retVal += "\t\tbr " + continueLabel + "\n";
			retVal += breakLabel + ":\n";

            currentContinueLabel = lastContinueLabel;
            currentBreakLabel = lastBreakLabel;
			
			return retVal;
		}

		public string Visit (NBreak nBreak) {
            return "\t\tbr " + currentBreakLabel + "\n";
		}

		public string Visit (NContinue nContinue) {
            return "\t\tbr " + currentContinueLabel + "\n";
		}

		public string Visit (NReturn nReturn) {
            string retVal = "";
			if (nReturn.children.Count == 1) {
				retVal += Visit((dynamic) nReturn[0]);
			}
			else { // Return 0
				retVal += "\t\tldc.i8 0\n";
			}
            retVal += "\t\tret\n";
			return retVal;
		}

		public string Visit (NExprOr nExprOr) {
			string retVal = "";
            retVal += Visit((dynamic) nExprOr[0]);
			string exitLabel = GenerateLabel();
            for(var i = 1; i < nExprOr.children.Count; i++){
				retVal += "\t\tdup\n";
				retVal += "\t\tbrtrue " + exitLabel + "\n";
				retVal += "\t\tpop\n";
            	retVal += Visit((dynamic) nExprOr[i]);
			}
			retVal += exitLabel + ":\n";
			return retVal;
		}

		public string Visit (NExprAnd nExprAnd) {
			string retVal = "";
            retVal += Visit((dynamic) nExprAnd[0]);
			string exitLabel = GenerateLabel();
            for(var i = 1; i < nExprAnd.children.Count; i++){
				retVal += "\t\tdup\n";
				retVal += "\t\tbrfalse " + exitLabel + "\n";
				retVal += "\t\tpop\n";
            	retVal += Visit((dynamic) nExprAnd[i]);
			}
			retVal += exitLabel + ":\n";
			return retVal;
		}

		public string Visit (NExprComp nExprComp) {
            string retVal = "";
            if (nExprComp.children.Count == 2) {
				string pushTrueValue = GenerateLabel();
				string pushFalseValue = GenerateLabel();
				string exitExpression = GenerateLabel();
                if (nExprComp.AnchorToken.Lexeme == "==") {
                    retVal += Visit((dynamic)nExprComp[0]);
                    retVal += Visit((dynamic)nExprComp[1]);
                    retVal += "\t\tceq\n";
					retVal += "\t\tbrtrue " + pushTrueValue + "\n";         
					retVal += "\t\tbr " + pushFalseValue + "\n"; 
                }
                else if (nExprComp.AnchorToken.Lexeme == "!=") {
                    retVal += Visit((dynamic)nExprComp[0]);
                    retVal += Visit((dynamic)nExprComp[1]);
                    retVal += "\t\tceq\n";
					retVal += "\t\tbrfalse " + pushTrueValue + "\n";         
					retVal += "\t\tbr " + pushFalseValue + "\n"; 
                }
				retVal += pushTrueValue + ":\n";
				retVal += "\t\tldc.i8 1\n";
				retVal += "\t\tbr " + exitExpression + "\n"; 
				retVal += pushFalseValue + ":\n";
				retVal += "\t\tldc.i8 0\n";
				retVal += exitExpression + ":\n";
            }
            else {
                retVal += Visit((dynamic) nExprComp[0]);
            }
			return retVal;
		}

		public string Visit (NExprRel nExprRel) {
            string retVal = "";
            if (nExprRel.children.Count == 2) {
				string pushTrueValue = GenerateLabel();
				string pushFalseValue = GenerateLabel();
				string exitExpression = GenerateLabel();
                if (nExprRel.AnchorToken.Lexeme == "<") {
                    retVal += Visit((dynamic)nExprRel[0]);
                    retVal += Visit((dynamic)nExprRel[1]);
					retVal += "\t\tclt\n";
                    retVal += "\t\tbrtrue " + pushTrueValue + "\n";
					retVal += "\t\tbr " + pushFalseValue + "\n";
                }
                else if (nExprRel.AnchorToken.Lexeme == "<=") {
                    retVal += Visit((dynamic)nExprRel[0]);
                    retVal += Visit((dynamic)nExprRel[1]);
                    retVal += "\t\tcgt\n"; 
                    retVal += "\t\tldc.i4.0\n";
                    retVal += "\t\tceq\n";
					retVal += "\t\tbrtrue " + pushTrueValue + "\n";
					retVal += "\t\tbr " + pushFalseValue + "\n";
                }
                else if (nExprRel.AnchorToken.Lexeme == ">") {
                    retVal += Visit((dynamic)nExprRel[0]);
                    retVal += Visit((dynamic)nExprRel[1]);
					retVal += "\t\tcgt\n";
                    retVal += "\t\tbrtrue " + pushTrueValue + "\n";
					retVal += "\t\tbr " + pushFalseValue + "\n";
                }
                else if (nExprRel.AnchorToken.Lexeme == ">=") {
                    retVal += Visit((dynamic)nExprRel[0]);
                    retVal += Visit((dynamic)nExprRel[1]);
                    retVal += "\t\tclt\n"; 
                    retVal += "\t\tldc.i4.0\n";
                    retVal += "\t\tceq\n";
					retVal += "\t\tbrtrue " + pushTrueValue + "\n";
					retVal += "\t\tbr " + pushFalseValue + "\n";
                }
				retVal += pushTrueValue + ":\n";
				retVal += "\t\tldc.i8 1\n";
				retVal += "\t\tbr " + exitExpression + "\n"; 
				retVal += pushFalseValue + ":\n";
				retVal += "\t\tldc.i8 0\n";
				retVal += exitExpression + ":\n";
            }
            else{
                retVal += Visit((dynamic) nExprRel[0]);
            }
			return retVal;
		}

		public string Visit (NExprBitOr nExprBitOr) {
			string retVal="";
			if (nExprBitOr.children.Count == 1) {
				retVal += Visit((dynamic)nExprBitOr[0]);
			}
			else {
				switch (nExprBitOr.AnchorToken.Lexeme) {
					case "^": {
						retVal += Visit((dynamic)nExprBitOr[0]);
						retVal += Visit((dynamic)nExprBitOr[1]);
						retVal += "\t\txor\n";	
						break;
					}
					case "|": {
						retVal += Visit((dynamic)nExprBitOr[0]);
						retVal += Visit((dynamic)nExprBitOr[1]);
						retVal += "\t\tor\n";	
						break;
					}
				}
			}
			return retVal;
		}

		public string Visit (NExprBitAnd nExprBitAnd) {
			string retVal="";
			if (nExprBitAnd.children.Count == 1) {
				retVal += Visit((dynamic)nExprBitAnd[0]);
			}
			else {
				retVal += Visit((dynamic)nExprBitAnd[0]);
				retVal += Visit((dynamic)nExprBitAnd[1]);
				retVal += "\t\tand\n";	
			}
			return retVal;
		}

		public string Visit (NExprBitShift nExprBitShift) {
			string retVal="";
			if (nExprBitShift.children.Count == 1) {
				retVal += Visit((dynamic) nExprBitShift[0]);
			}
			else {
				retVal += Visit((dynamic) nExprBitShift[0]);
				retVal += Visit((dynamic) nExprBitShift[1]);
				retVal += "\t\tconv.i4\n";
				if(nExprBitShift.AnchorToken.Category == TokenCategory.SHIFT_LEFT) {
					retVal += "\t\tshl\n";
				}
				else if(nExprBitShift.AnchorToken.Category == TokenCategory.SHIFT_RIGHT) {
					retVal += "\t\tshr\n";
				}
				else if(nExprBitShift.AnchorToken.Category == TokenCategory.SHIFT_RIGHT_ALT) {
					retVal += "\t\tshr.un\n";
				}	
			}
			return retVal;
		}	

		public string Visit (NExprAdd nExprAdd) {
			string retVal="";
			if(nExprAdd.children.Count==1){
				retVal += Visit((dynamic)nExprAdd[0]);
			}
			else{
				switch (nExprAdd.AnchorToken.Lexeme) {
					case "+": {
						retVal += Visit((dynamic)nExprAdd[0]);
						retVal += Visit((dynamic)nExprAdd[1]);
						retVal += "\t\tadd\n";	
						break;
					}
					case "-": {
						retVal += Visit((dynamic)nExprAdd[0]);
						retVal += Visit((dynamic)nExprAdd[1]);
						retVal += "\t\tsub\n";	
						break;
					}
				}
			}
			return retVal;
		}

		public string Visit (NExprMul nExprMul) {
			string retVal="";
			if(nExprMul.children.Count==1){
				retVal += Visit((dynamic)nExprMul[0]);
			}
			else{
				retVal += Visit((dynamic)nExprMul[0]);
				retVal += Visit((dynamic)nExprMul[1]);
				switch (nExprMul.AnchorToken.Lexeme) {
					case "*": {
						retVal += "\t\tmul\n";	
						break;
					}
					case "/": {
						retVal += "\t\tdiv\n";	
						break;
					}
					case "%": {
						retVal += "\t\trem\n";	
						break;
					}
				}
			}
			return retVal;
		}

		public string Visit (NExprPow nExprPow) {
			string retVal = "";
			if(nExprPow.children.Count == 1) {
				retVal += Visit((dynamic)nExprPow[0]);
			}
			else {
				retVal += Visit((dynamic)nExprPow[0]);
				retVal += Visit((dynamic)nExprPow[1]);
				retVal += "call int64 class ['int64lib']'Int64'.'Utils'::'pow'(int64, int64)\n";				
			}	
			return 	retVal;	
		}

		public string Visit (NExprUnary nExprUnary) {
			var retVal = "";
			Token anchorToken = nExprUnary.AnchorToken;
			retVal+=Visit((dynamic)nExprUnary[0]);
			if(anchorToken != null){
				switch(anchorToken.Category){
					case TokenCategory.ADDITION: {
						// Do nothing
						break;
					}
					case TokenCategory.SUBTRACTION: {
						// Multiply times -1
						retVal += "\t\tldc.i8 -1\n";
						retVal += "\t\tmul\n";
						break;
					}
					case TokenCategory.NOT /*!*/: {
						string pushTrueValue = GenerateLabel();
						string pushFalseValue = GenerateLabel();
						string exitExpression = GenerateLabel();
						retVal += "\t\tbrfalse " + pushTrueValue + "\n";
						retVal += "\t\tbr " + pushFalseValue + "\n";
						retVal += pushTrueValue + ":\n";
						retVal += "\t\tldc.i8 1\n";
						retVal += "\t\tbr " + exitExpression + "\n"; 
						retVal += pushFalseValue + ":\n";
						retVal += "\t\tldc.i8 0\n";
						retVal += exitExpression + ":\n";
						break;
					}
					case TokenCategory.BIT_NOT /*~*/: {
						retVal += "\t\tnot\n";
						break;
					}
				}
			}
			return retVal;
		}

		public string Visit (NExprPrimary nExprPrimary) {
			if (nExprPrimary.children.Count == 0) {
				Token anchorToken = nExprPrimary.AnchorToken;
				string lexeme = anchorToken.Lexeme;
				return loadVariable(lexeme);
			}
			return GenericChildVisitor(nExprPrimary);
		}

		public string Visit (NArrayList nArrayList) {
			string retVal="\t\tldc.i8 0\n";
			retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'New'(int64)\n";
			foreach (Node literal in nArrayList.children) {
				retVal += "\t\tdup\n";
				retVal += Visit((dynamic) literal);
				retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'add'(int64, int64)\n";
				retVal += "\t\tpop\n";				
			}
			return retVal;
		}

		public string GenericChildVisitor(Node node) {
			string retVal = "";
			foreach (Node n in node) {
				retVal += Visit((dynamic) n);
			}
			return retVal;
		}

		//--------------------------------------------------------------------------------
		// Literal Visitors Follow

		public string Visit (NLitBool nLitBool) {
			if(nLitBool.AnchorToken.Lexeme=="true")
				return "\t\tldc.i8 1\n";
			else
				return "\t\tldc.i8 0\n";
		}

		public string Visit (NLitInt nLitInt) {
			string retVal = "";
			Token token = nLitInt.AnchorToken;
			string lexeme = token.Lexeme;
			int lexemeLength = lexeme.Length;
			TokenCategory tokenCategory = token.Category;
			switch (tokenCategory) {
				case TokenCategory.BASE_2: {
					retVal = "\t\tldc.i8 " + Convert.ToInt64(lexeme.Substring(2, lexemeLength - 2), 2) + "\n";
					break;
				}
				case TokenCategory.BASE_8: {
					retVal = "\t\tldc.i8 " + Convert.ToInt64(lexeme.Substring(2, lexemeLength - 2), 8) + "\n";
					break;
				}
				case TokenCategory.BASE_10: {
					retVal = "\t\tldc.i8 " + lexeme + "\n";
					break;
				}
				case TokenCategory.BASE_16: {
					retVal = "\t\tldc.i8 " + Convert.ToInt64(lexeme.Substring(2, lexemeLength - 2), 16) + "\n";
					break;
				}
			}
			return retVal;
		}

		public string Visit (NLitChar nLitChar) {
			string lexeme = nLitChar.AnchorToken.Lexeme;
			int lexemeLength = lexeme.Length;
			string sanitizedLexeme = Regex.Replace(lexeme.Substring(1, lexemeLength - 2), @"\\[u]([0-9A-Fa-f]{6})", m => char.ToString((char) ushort.Parse(m.Groups[1].Value, NumberStyles.AllowHexSpecifier)));
			sanitizedLexeme = Regex.Unescape(sanitizedLexeme);
			IEnumerable<long> chars = Utils.AsCodePoints(sanitizedLexeme);
			foreach(long character in chars) {
				return "\t\tldc.i8 " + character + "\n";
			}
			return "";
		}

		public string Visit (NLitString nLitString) {
			string retVal = "\t\tldc.i8 0\n";
			retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'New'(int64)\n";
			string lexeme = nLitString.AnchorToken.Lexeme;
			int lexemeLength = lexeme.Length;
			string sanitizedLexeme = Regex.Replace(lexeme.Substring(1, lexemeLength - 2), @"\\[u]([0-9A-Fa-f]{6})", m => char.ToString((char) ushort.Parse(m.Groups[1].Value, NumberStyles.AllowHexSpecifier)));
			sanitizedLexeme = Regex.Unescape(sanitizedLexeme);
			IEnumerable<long> codePoints = Utils.AsCodePoints(sanitizedLexeme);
			foreach(long codePoint in codePoints) {
				retVal += "\t\tdup\n";
				retVal += "\t\tldc.i8 " + codePoint + "\n";
				retVal += "\t\tcall int64 class ['int64lib']'Int64'.'Utils'::'add'(int64, int64)\n";
				retVal += "\t\tpop\n";
			}
			return retVal;
		}
	}
}
